import { HTTP_STATUS } from '@/core/domain/constants';
import { getPHDateTime } from '@/core/utils/date.util';
import { ReferenceBusinessException } from '../exceptions';

export class Reference {
  id?: number;
  employee_id?: number;
  fname: string;
  mname?: string;
  lname: string;
  suffix?: string;
  cellphone_number?: string;
  deleted_by: string | null;
  deleted_at: Date | null;
  created_by: string | null;
  created_at: Date;
  updated_by: string | null;
  updated_at: Date;

  constructor(dto: {
    id?: number;
    employee_id?: number;
    fname: string;
    mname?: string;
    lname: string;
    suffix?: string;
    cellphone_number?: string;
    deleted_by?: string | null;
    deleted_at?: Date | null;
    created_by?: string | null;
    created_at?: Date; // Optional - auto-generated by TypeORM @CreateDateColumn()
    updated_by?: string | null;
    updated_at?: Date; // Optional - auto-generated by TypeORM @UpdateDateColumn()
  }) {
    this.id = dto.id;
    this.employee_id = dto.employee_id;
    this.fname = dto.fname;
    this.mname = dto.mname;
    this.lname = dto.lname;
    this.suffix = dto.suffix;
    this.cellphone_number = dto.cellphone_number;
    this.deleted_by = dto.deleted_by ?? null;
    this.deleted_at = dto.deleted_at ?? null;
    this.created_by = dto.created_by ?? null;
    // created_at and updated_at are auto-generated by TypeORM
    // They will be set when the entity is saved to the database
    this.created_at = dto.created_at ?? getPHDateTime();
    this.updated_by = dto.updated_by ?? null;
    this.updated_at = dto.updated_at ?? getPHDateTime();
  }

  /**
   * Creates a new reference instance with validation
   *
   * This static factory method creates a new reference record and validates it
   * to ensure it meets all business rules before being persisted.
   *
   * @param params - Reference creation parameters
   * @returns A new validated Reference instance
   */
  static create(params: {
    employee_id?: number;
    fname: string;
    mname?: string;
    lname: string;
    suffix?: string;
    cellphone_number?: string;
    created_by?: string | null;
  }): Reference {
    const reference = new Reference({
      employee_id: params.employee_id,
      fname: params.fname,
      mname: params.mname,
      lname: params.lname,
      suffix: params.suffix,
      cellphone_number: params.cellphone_number,
      created_by: params.created_by ?? null,
      // Note: created_at and updated_at are auto-generated by TypeORM
      // They will be set automatically when the entity is saved
    });
    // Validate the reference before returning
    reference.validate();
    return reference;
  }

  /**
   * Updates the reference details
   *
   * @param dto - Reference data containing fields to update
   * @param updated_by - Username of the user performing the update
   */
  update(dto: {
    fname?: string;
    mname?: string;
    lname?: string;
    suffix?: string;
    cellphone_number?: string;
    updated_by?: string | null;
  }): void {
    if (this.deleted_at) {
      throw new ReferenceBusinessException(
        'Reference is archived and cannot be updated',
        HTTP_STATUS.CONFLICT,
      );
    }

    if (dto.fname !== undefined) {
      this.fname = dto.fname;
    }
    if (dto.mname !== undefined) {
      this.mname = dto.mname;
    }
    if (dto.lname !== undefined) {
      this.lname = dto.lname;
    }
    if (dto.suffix !== undefined) {
      this.suffix = dto.suffix;
    }
    if (dto.cellphone_number !== undefined) {
      this.cellphone_number = dto.cellphone_number;
    }
    this.updated_by = dto.updated_by ?? null;
    // Note: updated_at is auto-generated by TypeORM @UpdateDateColumn() when saved
    // We don't set it here - it will be updated automatically by TypeORM on persistence
    this.validate();
  }

  /**
   * Archives (soft deletes) the reference
   *
   * @param deleted_by - Username of the user performing the archive
   */
  archive(deleted_by: string): void {
    if (this.deleted_at) {
      throw new ReferenceBusinessException(
        'Reference is already archived.',
        HTTP_STATUS.CONFLICT,
      );
    }

    this.deleted_at = getPHDateTime();
    this.deleted_by = deleted_by;
  }

  /**
   * Restores a previously archived reference
   */
  restore(): void {
    if (!this.deleted_at) {
      throw new ReferenceBusinessException(
        `Reference with ID ${this.id} is not archived.`,
        HTTP_STATUS.CONFLICT,
      );
    }

    this.deleted_at = null;
    this.deleted_by = null;
  }

  /**
   * Validates the reference against business rules
   *
   * This method enforces domain validation rules such as:
   * - First name and last name are required and must meet length requirements
   * - Name fields must match pattern requirements (letters, spaces, hyphens, apostrophes, periods)
   * - Optional fields must meet validation rules if provided
   * - Employee ID must be a positive number if provided
   *
   * @throws ReferenceBusinessException - If validation fails
   */
  validate(): void {
    // Validate if employee_id is provided and is a positive number
    if (this.employee_id !== undefined && this.employee_id !== null) {
      if (this.employee_id <= 0) {
        throw new ReferenceBusinessException(
          'Employee ID must be a positive number if provided.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }
    }

    // Validate if fname is provided
    if (!this.fname || this.fname.trim().length === 0) {
      throw new ReferenceBusinessException(
        'First name is required and cannot be empty.',
        HTTP_STATUS.BAD_REQUEST,
      );
    }

    // Validate if fname length is within limits (100 characters max based on DTO)
    if (this.fname.length > 100) {
      throw new ReferenceBusinessException(
        'First name must not exceed 100 characters.',
        HTTP_STATUS.BAD_REQUEST,
      );
    }

    // Validate if fname matches pattern (letters, spaces, hyphens, apostrophes, periods)
    const namePattern = /^[a-zA-Z\s\-'.,]+$/;
    if (!namePattern.test(this.fname)) {
      throw new ReferenceBusinessException(
        'First name can only contain letters, spaces, hyphens, apostrophes, and periods.',
        HTTP_STATUS.BAD_REQUEST,
      );
    }

    // Validate optional mname if provided
    if (this.mname !== undefined && this.mname !== null) {
      if (this.mname.trim().length === 0) {
        throw new ReferenceBusinessException(
          'Middle name cannot be empty if provided.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }

      if (this.mname.length > 100) {
        throw new ReferenceBusinessException(
          'Middle name must not exceed 100 characters.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }

      if (!namePattern.test(this.mname)) {
        throw new ReferenceBusinessException(
          'Middle name can only contain letters, spaces, hyphens, apostrophes, and periods.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }
    }

    // Validate if lname is provided
    if (!this.lname || this.lname.trim().length === 0) {
      throw new ReferenceBusinessException(
        'Last name is required and cannot be empty.',
        HTTP_STATUS.BAD_REQUEST,
      );
    }

    // Validate if lname length is within limits (100 characters max based on DTO)
    if (this.lname.length > 100) {
      throw new ReferenceBusinessException(
        'Last name must not exceed 100 characters.',
        HTTP_STATUS.BAD_REQUEST,
      );
    }

    // Validate if lname matches pattern
    if (!namePattern.test(this.lname)) {
      throw new ReferenceBusinessException(
        'Last name can only contain letters, spaces, hyphens, apostrophes, and periods.',
        HTTP_STATUS.BAD_REQUEST,
      );
    }

    // Validate optional suffix if provided
    if (this.suffix !== undefined && this.suffix !== null) {
      if (this.suffix.trim().length === 0) {
        throw new ReferenceBusinessException(
          'Suffix cannot be empty if provided.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }

      if (this.suffix.length > 10) {
        throw new ReferenceBusinessException(
          'Suffix must not exceed 10 characters.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }

      const suffixPattern = /^[a-zA-Z.]+$/;
      if (!suffixPattern.test(this.suffix)) {
        throw new ReferenceBusinessException(
          'Suffix can only contain letters and periods.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }
    }

    // Validate optional cellphone_number if provided
    if (this.cellphone_number !== undefined && this.cellphone_number !== null) {
      if (this.cellphone_number.trim().length === 0) {
        throw new ReferenceBusinessException(
          'Cellphone number cannot be empty if provided.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }

      if (this.cellphone_number.length < 10) {
        throw new ReferenceBusinessException(
          'Cellphone number must be at least 10 characters long.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }

      if (this.cellphone_number.length > 15) {
        throw new ReferenceBusinessException(
          'Cellphone number must not exceed 15 characters.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }

      const phonePattern = /^[0-9+\-\s()]+$/;
      if (!phonePattern.test(this.cellphone_number)) {
        throw new ReferenceBusinessException(
          'Cellphone number can only contain numbers, plus signs, hyphens, spaces, and parentheses.',
          HTTP_STATUS.BAD_REQUEST,
        );
      }
    }
  }
}
